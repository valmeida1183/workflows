name: Deploy Project

on:
  workflow_run:
    workflows: ['Build Project'] # Inicia quando o workflow "Build Project" é concluído.
    types:
      - completed

env:
  DOCKER_IMAGE_REGISTRY: '${{ vars.DOCKER_CONTAINER_REGISTRY }}/${{vars.DOCKERHUB_REPOSITORY}}/todo-app' # Define o registro da imagem Docker

jobs:
  versioning:
    runs-on: ubuntu-latest # Define o ambiente de execução do job
    outputs:
      version: ${{ steps.get-version.outputs.version }} # Define a saída do job como a versão definida no step set-version
      docker-container-registry: ${{ steps.docker-image-registry.outputs.docker-container-registry }} # Define a saída do job como o registro da imagem Docker

    steps:
      - uses: actions/download-artifact@v4 # Faz o download do artefato version.txt criado no job de build
        with:
          name: version # Nome do artefato a ser baixado, que contém o arquivo com a versão criada no workflow de build
          path: ./ # Caminho onde o artefato será baixado, que é a raiz do repositório
          github-token: ${{ secrets.GITHUB_TOKEN }} # Token do GitHub para autenticação
          run-id: ${{ github.event.workflow_run.id }} # ID do workflow que disparou o evento, garantindo que o artefato correto seja baixado

      - name: Get version from file # Lê o conteúdo do arquivo version.txt e define como saída do job
        id: get-version # Define um ID para o step, que pode ser usado para referenciar a saída
        run: |
          VERSION=$(cat ./version.txt) # Lê o conteúdo do arquivo version.txt e armazena na variável VERSION
          echo "::notice:: $VERSION" # Exibe uma mensagem de aviso com a versão obtida
          echo "::set-output name=version::$VERSION" >> "$GITHUB_OUTPUT" # Define a saída do step com o valor da variável VERSION

      - name: Generate docker image registry # Gera o registro da imagem Docker com a versão obtida
        id: docker-image-registry # Define um ID para o step, que pode ser usado para referenciar a saída
        run: |
          echo "::set-output name=docker-container-registry::${{ env.DOCKER_IMAGE_REGISTRY }}:${{ steps.get-version.outputs.version }}"  >> "GITHUB_OUTPUT" # Define a saída do step com o registro da imagem Docker, que inclui a versão obtida

  deploy-to-goolgle-cloud:
    name: Deploy to Google Cloud
    runs-on: ubuntu-latest
    needs: versioning # Define que esse job depende do job de versionamento, ou seja, só será executado após o término do job de versionamento
    permissions: # Define as permissões necessárias para o job
      contents: read # Permite ler o conteúdo do repositório
      id-token: write # Permite escrever o token de ID para autenticação e utilização de serviços externos no caso o Google Cloud
    strategy: # Define uma estratégia de matriz para rodar o CodeQL em diferentes linguagens
      matrix:
        environment: ['Staging', 'Production'] # Define os ambientes onde o deploy será feito, que são Staging e Production
    environment: ${{ matrix.environment }} # Define o ambiente de execução do job, que pode ser Staging ou Production

    steps:
      - uses: google-github-actions/auth@v2 # Ação para autenticação no Google Cloud
        with:
          credentials_json: ${{ secrets.GCP_CREDENTIALS }} # Credenciais do Google Cloud armazenadas como segredo
          project_id: ${{ vars.GCP_PROJECT_ID }} # ID do projeto do Google Cloud armazenado como variável

      - uses: google-github-actions/deploy-cloudrun@v2 # Ação para implantar no Cloud Run
        id: deploy-to-cloud-run # Define um ID para o step, que pode ser usado para referenciar a saída
        with:
          project_id: ${{ vars.GCP_PROJECT_ID }} # ID do projeto do Google Cloud
          service: ${{ vars.GCP_RUN_SERVICE }} # Nome do serviço do Cloud
          image: ${{ needs.versioning.outputs.docker-container-registry }} # Imagem Docker a ser implantada, que é o registro da imagem Docker com a versão obtida no job de versionamento
          region: ${{ vars.GCP_RUN_REGION }} # Região do Google Cloud onde o serviço será implantado

      - name: 'Test the deployment' # Testa a implantação do serviço no Cloud Run
        run: |-
          echo "::notice:: ${{ steps.deploy-to-cloud-run.outputs.url }}/index.html" # Exibe a URL do serviço implantado
          curl -I --fail "${{ steps.deploy-to-cloud-run.outputs.url }}/index.html" # Faz uma requisição HTTP para a URL do serviço implantado e verifica se a resposta é bem-sucedida (status 200)

  deploy-to-azure:
    name: Deploy to Azure
    runs-on: ubuntu-latest
    needs: versioning # Define que esse job depende do job de versionamento, ou seja, só será executado após o término do job de versionamento
    permissions: # Define as permissões necessárias para o job
      contents: read # Permite ler o conteúdo do repositório
      id-token: write # Permite escrever o token de ID para autenticação e utilização de serviços externos no caso o Google Cloud
    strategy: # Define uma estratégia de matriz para rodar o CodeQL em diferentes linguagens
      matrix:
        environment: ['Staging', 'Production'] # Define os ambientes onde o deploy será feito, que são Staging e Production
    environment: Staging #${{ matrix.environment }} # Define o ambiente de execução do job, que pode ser Staging ou Production

    steps:
      - name: Deploy Docker to Azure
        id: deploy-to-azure # Define um ID para o step, que pode ser usado para referenciar a saída
        uses: azure/webapps-deploy@v3 # Ação para implantar no Azure Web Apps
        with:
          app-name: ${{ vars.AZURE_WEBAPP_NAME }} # Nome do aplicativo no Azure Web Apps
          resource-group-name: ${{ vars.AZURE_RESOURCE_GROUP }} # Nome do grupo de recursos do Azure
          publish-profile: ${{ secrets.AZURE_WEBAPP_PUBLISH_PROFILE }} # Perfil de publicação do Azure Web Apps armazenado como segredo
          images: ${{ needs.versioning.outputs.docker-container-registry }} # Imagem Docker a ser implantada, que é o registro da imagem Docker com a versão obtida no job de
      - name: 'Test the deployment' # Testa a implantação do serviço no Cloud Run
        run: |-
          echo "::notice:: ${{ steps.deploy-to-webapp.outputs.url }}/index.html" # Exibe a URL do serviço implantado
          curl -I --fail "${{ steps.deploy-to-webapp.outputs.url }}/index.html" # Faz uma requisição HTTP para a URL do serviço implantado e verifica se a resposta é bem-sucedida (status 200)

  deploy-to-amazon-aws:
    name: Deploy to Amazon AWS
    runs-on: ubuntu-latest
    needs: versioning # Define que esse job depende do job de versionamento, ou seja, só será executado após o término do job de versionamento
    permissions: # Define as permissões necessárias para o job
      contents: read # Permite ler o conteúdo do repositório
      id-token: write # Permite escrever o token de ID para autenticação e utilização de serviços externos no caso o Google Cloud
    strategy: # Define uma estratégia de matriz para rodar o CodeQL em diferentes linguagens
      matrix:
        environment: ['Staging', 'Production'] # Define os ambientes onde o deploy será feito, que são Staging e Production
    environment: Production #${{ matrix.environment }} # Define o ambiente de execução do job, que pode ser Staging ou Production
    env:
      TASK_DEFINITION_PATH: ./infra/aws/amazon-ecs-task-definition.json # Caminho para o arquivo de definição da tarefa do Amazon ECS

    steps:
      - uses: actions/checkout@v4 # Faz o checkout do repositório para obter o código-fonte e os arquivos necessários para o deploy

      - name: Configure AWS credentials # Configura as credenciais da AWS para autenticação
        uses: aws-actions/configure-aws-credentials@v4 # Ação para configurar as credenciais da AWS
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }} # Chave de acesso da AWS armazenada como segredo
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }} # Chave secreta da AWS armazenada como segredo
          aws-region: ${{ vars.AWS_REGION }} # Região da AWS onde o serviço será implantado

      - name: Update the Amazon ECS task definition with image docker version # Atualiza a definição da tarefa do Amazon ECS com a versão da imagem Docker
        id: task-definition # Define um ID para o step, que pode ser usado para referenciar a saída
        uses: aws-actions/amazon-ecs-render-task-definition@v1 # Ação para renderizar o arquivo de definição da tarefa do Amazon ECS
        with:
          task-definition: ${{ env.TASK_DEFINITION_PATH }} # Caminho para o arquivo de definição da tarefa do Amazon ECS
          container-name: ${{ vars.AWS_ECS_CONTAINER_NAME }} # Nome do contêiner definido na tarefa do Amazon ECS
          image: ${{ needs.versioning.outputs.docker-container-registry }} # Imagem Docker a ser usada na tarefa, que é o registro da imagem Docker com
          environment-variables: |
            SQL_CONNECTION_STRING_KEY=ConnectionStrings:TodoDb
            ConnectionStrings:TodoDb=${{ secrets.AZURE_SQL_CONNECTION_STRING }} # Variáveis de ambiente a serem passadas para o contêiner, incluindo a string de conexão do banco de dados SQL do Azure

      - name: Deploy to Amazon ECS task definition # Implanta a tarefa do Amazon ECS com a definição atualizada
        id: deploy-to-ecs # Define um ID para o step, que pode ser usado para referenciar a saída
        uses: aws-actions/amazon-ecs-deploy-task-definition@v2 # Ação para implantar a tarefa do Amazon ECS
        timeout-minutes: 10 # Define o tempo limite para a implantação, que é de 30 minutos
        with:
          task-definition: ${{ steps.task-definition.outputs.task-definition }} # Definição da tarefa atualizada com a imagem Docker e variáveis de ambiente
          cluster: ${{ vars.AWS_ECS_CLUSTER_NAME }} # Nome do cluster do Amazon ECS onde a tarefa será implantada
          service: ${{ vars.AWS_ECS_SERVICE_NAME }} # Nome do serviço do Amazon ECS onde a tarefa será implantada

      - name: 'Test the deployment' # Testa a implantação do serviço no Cloud Run
        run: |-
          echo "::notice:: ${{ vars.AWS_ECS_LOAD_BALANCER_ENDPOINT }}/index.html" # Exibe a URL do serviço implantado
          curl -I --fail "${{ vars.AWS_ECS_LOAD_BALANCER_ENDPOINT }}/index.html" # Faz uma requisição HTTP para a URL do serviço implantado e verifica se a resposta é bem-sucedida (status 200)
